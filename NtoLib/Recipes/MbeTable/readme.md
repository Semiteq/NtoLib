# Функциональный блок "Таблица рецептов MBE" (MbeTableFB)

**MbeTableFB** — это гибкий функциональный блок для **MasterSCADA 3.12**, предназначенный для создания, управления и исполнения технологических рецептов.

![MbeTableFB](MbeTableFB.png)

## 1. Ключевые возможности

*   **Гибкая настройка:** Вся бизнес-логика, структура таблицы и набор команд определяются в текстовых YAML-файлах.
*   **Динамический интерфейс:** Пользовательский интерфейс (столбцы, редакторы, выпадающие списки) генерируется автоматически на основе конфигурации.
*   **Мониторинг в реальном времени:** Отслеживание исполнения рецепта, подсветка текущего шага и расчет оставшегося времени до конца шага и рецепта.
*   **Интеграция с ПЛК:** Прямое взаимодействие с контроллерами по протоколу Modbus TCP для записи параметров рецепта.
*   **Динамическое создание пинов:** Пины для связи с оборудованием создаются автоматически на основе файла `PinGroupDefs.yaml`.

## 2. Требования к окружению

*   **Среда исполнения:** MasterSCADA 3.12.
*   **Зависимости:** .NET Framework 4.8.

## 3. Установка и первоначальная настройка

1.  **Установка библиотеки:**
    *   Скопируйте библиотеку `NtoLib.dll` и `System.Resources.Extensions.dll` в корневую папку установки MasterSCADA.
    *   Зарегистрируйте сборку с помощью утилиты `netreg.exe`.

2.  **Создание папки конфигурации:**
    *   В корневой директории, где установлена MasterSCADA создайте папку с именем `NtoLibTableConfig`.

3.  **Размещение конфигурационных файлов:**
    *   Поместите в папку `NtoLibTableConfig` четыре обязательных YAML-файла:
        *   `PropertyDefs.yaml`
        *   `PinGroupDefs.yaml`
        *   `ColumnDefs.yaml`
        *   `ActionsDefs.yaml`

4.  **Добавление блока в проект:**
    *   Перезапустите среду разработки MasterSCADA.
    *   Добавьте функциональный блок "Таблица рецептов MBE" на схему в вашем проекте.

## 4 Конфигурация через YAML-файлы

### Обзор и порядок загрузки

Модуль использует 4 YAML-файла для полной настройки.
1.  `PropertyDefs.yaml`
2.  `ColumnDefs.yaml` (проверяются ссылки на `PropertyDefs`)
3.  `PinGroupDefs.yaml`
4.  `ActionsDefs.yaml` (проверяются ссылки на `ColumnDefs`, `PinGroupDefs` и `PropertyDefs`)

Ошибка на любом этапе прерывает запуск модуля, блокируя загрузку с невалидными данными.

### 4.1. `PropertyDefs.yaml` — Словарь типов данных

*   **Назначение:** Определяет примитивы данных — типы, их ограничения и форматирование.

*   **Пример:**
    ```yaml
    - property_type_id: "Temp"      # Уникальный ID. Используется в ColumnDefs и ActionsDefs.
      system_type: "System.Single"  # Тип в .NET. Допустимы: System.Single, System.Int32, System.String.
      units: "°C"                   # Единицы измерения для UI. Могут принимать любое текстовое значение. При валидации отбрасываются и в логике не участвуют.
      min: 0                        # Минимально допустимое значение (для числовых типов) в пределах указанного типа (float или Int32).
      max: 2000                     # Максимально допустимое значение в пределах указанного типа (float или Int32).
      format_kind: "Numeric"           # Формат отображения. Варианты: Numeric, Scientific, TimeHms. Numeric выводит данные в формате 123.## с опциональной дробной частью, Scientific 123.##E123, TimeHms 01:02:03.###. Значения, введенные с большим количеством знаков после запятой, будут округлены до 2 знаков.

    - property_type_id: "Enum"      # Специальный тип для перечислений.
      system_type: "System.Int32"   # Внутреннее представление - целое число.
      units: ""
      format_kind: "Numeric"

    - property_type_id: "String"    # Тип для текстовых комментариев.
      system_type: "System.String"
      units: ""
      max_length: 255               # Максимальная длина строки.
      format_kind: "Numeric"
    ```

*   **Правила валидации и уникальность:**
    *   `property_type_id`: **Обязательное поле. Должно быть уникальным** (регистронезависимо).
    *   `system_type`: **Обязательное поле.** Должен быть одним из поддерживаемых типов.

### 4.2. `PinGroupDefs.yaml` — Карта аппаратных средств

*   **Назначение:** Описывает оборудование, связывая имена (например, "Клапаны") с диапазонами пинов. ID в паре key-value (id-Имя) пинов, отображаемые в скаде, будут нумероваться с 1. Так в примере ниже будут созданы пары 1 - Valve1, 2 - Valve2 и так далее.

*   **Пример:**
    ```yaml
    - group_name: "Valve"          # Уникальное имя. Используется в ActionsDefs для привязки к Enum.
      pin_group_id: 450           # Уникальный ID группы узлов в дереве FB MasterSCADA.
      first_pin_id: 451           # ID первого пина в группе в дереве FB MasterSCADA.
      pin_quantity: 32            # Количество пинов. Будут созданы пины с 451 по 482.

    - group_name: "TempSensor"
      pin_group_id: 400
      first_pin_id: 401
      pin_quantity: 16
    ```

*   **Правила валидации и уникальность:**
    *   `group_name`: **Обязательное, уникальное** (регистронезависимо).
    *   `pin_group_id`: **Обязательное, уникальное**.
    *   Все числовые поля (`pin_group_id`, `first_pin_id`, `pin_quantity`) должны быть > 0.
    *   Диапазоны пинов **не должны пересекаться** между группами.

### 4.3. `ColumnDefs.yaml` — Структура таблицы рецептов

*   **Назначение:** Полное описание каждого столбца в таблице рецептов.

*   **Пример:**
    ```yaml
    - key: "initial_value"            # Уникальный ключ столбца. Используется в ActionsDefs.
      business_logic:
        property_type_id: "Float"     # Ссылка на ID из PropertyDefs.yaml. Указывает на тип данных в ячейке.
        read_only: false              # false - столбец можно редактировать, true - нельзя.
        plc_mapping:                  # Как значение будет отправлено в ПЛК (опционально). Если не указано то поле не будет передаваться в ПЛК.
          area: "Float"               # Область памяти ПЛК ("Int", "Float").
          index: 0                    # Смещение (индекс) внутри области для данной строки рецепта.
      ui:
        code: "initial_value"         # Внутренний код, обычно совпадает с key. Используется для записи и чтения csv.
        ui_name: "Поток/Нач.знач."    # Заголовок столбца в таблице.
        column_type: "property_field" # Тип UI-элемента (определяет фабрику для создания):
                                      # action_combo_box - выпадающий список для Action, обязательно должен присутствовать.
                                      # action_target_combo_box - выпадающий список для выбора цели действия, может быть несколько или не быть.
                                      # property_field - стандарнтое поле ввода/вывода численных данных.
                                      # step_start_time_field - особое поле времени начала шага, обязательно должно присутствовать.
                                      # text_field - тексктовое поле.
        width: 160                    # Ширина столбца в пикселях. -1 означает "занять все оставшееся место".
        alignment: 32                 # Выравнивание контента (16=Left, 32=Center, 64=Right).
    ```
*   **Правила валидации и уникальность:**
    *   `key`: **Обязательное, уникальное** (регистронезависимо).
    *   `business_logic.property_type_id`: **Обязательное.** Значение **должно существовать** в `PropertyDefs.yaml`.

#### Особые конфигурации столбцов

Некоторые столбцы имеют предопределенное поведение, управляемое их `key`.
Наличие столбцов `Action`, `step_duration`, `step_start_time` и `comment` обязательно для работы.

*   **Столбец выбора действия**
    *   Это главный столбец, который определяет, какая команда выполняется в строке. Обычно имеет `column_type: "action_combo_box"`.
    ```yaml
    - key: "action"
      business_logic:
        role: "action"
        property_type_id: "Enum"
      # ...
    ```

*   **Столбец комментария (`key: "comment"`)**
    *   Предназначен для текстовых примечаний. Чтобы он занимал все оставшееся место в таблице, используется `width: -1`.
    ```yaml
    - key: "comment"
      business_logic:
        role: "comment"
        property_type_id: "String"
      ui:
        # ...
        width: -1
    ```

### 4.4. `ActionsDefs.yaml` — Словарь команд (действий)

*   **Назначение:** Определяет доступные пользователю команды и связывает их со столбцами, типами данных и оборудованием.

*   **Пример:**
    ```yaml
    - id: 1100                       # Уникальный числовой ID действия.
      name: "Open"                   # Имя, которое пользователь видит в выпадающем списке столбца "action".
      deploy_duration: "Immediate"   # Тип длительности. Immediate - мгновенное действие, не учитывается duration в расчете общего времени. LongLasting - учитывается.
      columns:
        - key: "channel"             # Для этой команды используется столбец с ключом "channel"
          property_type_id: "Enum"   # В контексте этой команды, "channel" имеет тип "Enum".
          group_name: "Valves"       # Выпадающий список для "channel" будет заполнен именами из группы "Valves" из PinGroupDefs.yaml
        - key: "comment"             # Также используется столбец "comment"
          property_type_id: "String"

    - id: 10
      name: "Wait_Time"
      deploy_duration: "LongLasting"  # Это действие определяет длительность шага.
      columns:
        - key: "step_duration"        # Используем столбец "step_duration"
          property_type_id: "Time"    # Тип данных - время
          default_value: "10"         # Значение по умолчанию при создании строки - 10 секунд. Значение по умолчанию есть только у численных полей. Для выпадающих списков берется с минимальным id.
        - key: "comment"
          property_type_id: "String"
    ```
*   **Правила валидации и уникальность:**
    *   `id`: **Обязательное, уникальное**.
    *   `columns.key`: **Обязательное.** Значение **должно существовать** в `ColumnDefs.yaml`.
    *   `columns.group_name`: **Обязательное, если `property_type_id` = "Enum"**. Значение **должно существовать** в `PinGroupDefs.yaml`.
    *   `columns.property_type_id`: **Обязательное.** Значение **должно существовать** в `PropertyDefs.yaml`. Это позволяет "переопределять" тип данных столбца для конкретной команды.


## 5. Интеграция и внешнее взаимодействие

### 5.1. Пины функционального блока (FB Pins)

#### Входные пины (Inputs)
*   `RecipeActive` (ID: 1, bool): При `true` блокирует редактирование таблицы и переводит ее в режим исполнения.
*   `ActualLineNumber` (ID: 3, int): Номер текущей исполняемой строки (начиная с 0) для визуальной подсветки.
*   `StepCurrentTime` (ID: 4, float): Время в секундах, прошедшее с начала текущего шага.
*   `ForLoopCount1-3` (ID: 5-7, int): Номер итерации для отслеживания вложенных циклов `FOR`.
*   `EnaSend` (ID: 8, bool): Глобальное разрешение на отправку данных в ПЛК по Modbus.

#### Выходные пины (Outputs)
*   `TotalTimeLeft` (ID: 101, float): Расчетное общее время (в секундах) до конца выполнения всего рецепта.
*   `LineTimeLeft` (ID: 102, float): Расчетное время (в секундах) до конца выполнения текущего шага.

---

### 5.2. Взаимодействие с ПЛК по Modbus TCP

Модуль обменивается данными с ПЛК по Modbus TCP для загрузки и верификации рецепта.

#### Настраиваемые свойства FB для связи
Параметры подключения задаются в свойствах блока `MbeTableFB` в MasterSCADA:
*   `UControllerIp1` - `UControllerIp4`: IP-адрес ПЛК.
*   `ControllerTcpPort`: TCP-порт (стандартно 502).
*   `UControlBaseAddr`: Начальный адрес **Контрольной области**.
*   `UIntBaseAddr`, `UIntAreaSize`: Начальный адрес и размер **Области целочисленных данных (Int)**.
*   `UFloatBaseAddr`, `UFloatAreaSize`: Начальный адрес и размер **Области вещественных данных (Float)**.
*   **Word Order**: HighLow.

#### Карта памяти ПЛК
Программист ПЛК должен подготовить три области памяти:

```ascii
              КАРТА ПАМЯТИ ПЛК ДЛЯ РЕЦЕПТОВ

+-------------------------------------------------------------+
| КОНТРОЛЬНАЯ ОБЛАСТЬ (UControlBaseAddr)                      |
|-------------------------------------------------------------|
| R0: Валидация (69) | R1: Кол-во строк | R2-R9: Резерв       |
+-------------------------------------------------------------+

                              ...

+-------------------------------------------------------------+
| ОБЛАСТЬ INT ДАННЫХ (UIntBaseAddr)                           |
|-------------------------------------------------------------|
| [Все Int-значения для всех строк рецепта идут подряд...]    |
|                                                             |
+-------------------------------------------------------------+

                              ...

+-------------------------------------------------------------+
| ОБЛАСТЬ FLOAT ДАННЫХ (UFloatBaseAddr)                       |
|-------------------------------------------------------------|
| [Все Float-значения для всех строк рецепта идут подряд...]  |
| (Каждое Float значение занимает 2 регистра)                 |
+-------------------------------------------------------------+
```

**1. Контрольная область (Control Area)**
*   **Адрес:** `UControlBaseAddr`, **Размер:** 10 регистров.

| Смещение | Регистр | Назначение |
|:---|:---|:---|
| **+0** | **R0** | **Регистр валидации.** Должен содержать константу `69`. |
| **+1** | **R1** | **Количество строк рецепта.** Сюда записывается общее число шагов. |
| +2..+9 | R2-R9 | Зарезервировано. |

**2. Область целочисленных данных (Int Area)**
*   **Адрес:** `UIntBaseAddr`, **Размер:** `UIntAreaSize`.
*   Хранит все целочисленные параметры рецепта в виде одного массива.

**3. Область вещественных данных (Float Area)**
*   **Адрес:** `UFloatBaseAddr`, **Размер:** `UFloatAreaSize`.
*   Хранит все вещественные параметры. Каждое `float` значение занимает **2 регистра Modbus**.

#### Процесс отправки и верификации (`SendAndVerify`)
1.  **Проверка вместимости:** Система проверяет, помещается ли рецепт в выделенные `AreaSize`.
2.  **Подключение и валидация:** Модуль подключается к ПЛК и проверяет регистр валидации (должен быть равен `69`).
3.  **Сериализация:** Таблица рецепта преобразуется в два плоских массива: `int[]` и `float[]`.
4.  **Запись в ПЛК:** Данные отправляются в контроллер. Большие объемы автоматически разбиваются на пакеты.
5.  **Пауза (200 мс):** Дает ПЛК время на обработку данных.
6.  **Чтение из ПЛК:** Модуль считывает все данные обратно из контроллера.
7.  **Верификация:** Считанный рецепт сравнивается с оригинальным. Если данные совпадают (с учетом погрешности для `float`), операция считается успешной.

---

### 5.3. Импорт и экспорт рецептов в CSV

Модуль поддерживает сохранение и загрузку рецептов в формате `.csv`. Файл должен быть в кодировке **UTF-8 with BOM**.

#### Структура файла
1.  **Блок метаданных:** Строки, начинающиеся с `#`. Содержат служебную информацию для проверки целостности.
2.  **Блок данных:** Стандартный CSV-формат, где первая строка — заголовки столбцов.

**Пример файла:**
```csv
# SEP=;
# ROWS=3
# BODY_SHA256=hFh0A79U9dIXrt3lcxHud6W5rJwTE6EmBmuTIuwmYs0=
# X_ExportedAtLocalTime=2025-09-18T17:31:55+03:00
action;channel;mode;initial_value;final_value;step_duration;comment
200;1;1;0;0;0;
200;1;1;32;44;123;комментарий
100;1;1;10;10;10;
```

#### Процесс импорта (чтения)
При загрузке `.csv` файла происходит многоуровневая валидация:
1.  **Проверка метаданных:** Система сверяет разделитель (`# SEP`), количество строк (`# ROWS`) и хеш-сумму данных (`# BODY_SHA256`).
2.  **Проверка совместимости:** Система анализирует, существует ли указанное в рецепте оборудование (например, клапан №1) в текущей конфигурации `PinGroupDefs.yaml`.

> При любом несоответствии загрузка файла прерывается с выводом ошибки.

#### Процесс экспорта (записи)
*   При сохранении все мета-поля генерируются автоматически.
*   Экспортируются только те столбцы, у которых в `ColumnDefs.yaml` **не установлен** флаг `read_only: true`.
*   Запись происходит безопасно через временный `.tmp` файл для предотвращения порчи данных.

## 6. Диагностика

Для анализа работы модуля и поиска неисправностей используется лог-файл:
*   **`debug_logger.txt`**: Файл создается автоматически в директории `C:\Users\<Имя_Пользователя>\AppData\Roaming\NtoLibLogs\`. В него записываются все ключевые операции: загрузка конфигурации, ошибки валидации, процесс обмена с ПЛК и т.д.